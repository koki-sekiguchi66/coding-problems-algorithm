# すごろく問題の解説（灰〜茶レベル向け）

## 問題の整理

まず、問題を整理してみましょう。

### ゲームのルール
1. マス0からスタートし、マスN以上に到達するとゴール
2. **ステップ1**: サイコロを振る（1〜6の好きな目を選べる）
3. **ステップ2**: 着いたマスに書かれた数だけ進むかどうかを**選択**できる
4. **ステップ3**: 進むと決めた場合、その数だけ強制的に進む→ステップ2に戻る

### 入力例の確認
```
10
0 0 0 0 0 1 1 1 1
```
- N=10（マス10以上でゴール）
- マス1〜9にそれぞれ `0 0 0 0 0 1 1 1 1` が書かれている

## なぜこの問題が難しいのか？

### 状態が複雑
普通のすごろくと違って、この問題では**2つの状態**があります：

1. **サイコロを振る状態**：次にサイコロを振らなければいけない
2. **選択できる状態**：マスの数を使って進むか、サイコロを振り直すかを選べる

### 例で理解してみよう
マス0からスタートして、サイコロで6を出してマス6に到着したとします。

```
マス6の値は1なので...
├─ 選択肢A：1だけ進んでマス7へ（マス7でまた選択できる）
└─ 選択肢B：進まずにサイコロを振り直す
```

マス7に進んだ場合：
```
マス7の値も1なので...
├─ 選択肢A：1だけ進んでマス8へ
└─ 選択肢B：進まずにサイコロを振り直す
```

このように**連鎖的に進める**可能性があるのが複雑な点です。

## 解法のアイデア：BFS（幅優先探索）

### なぜBFSなのか？
- 「最小のサイコロ回数」を求める問題
- BFSは**最短経路**を求めるのに適している
- サイコロ回数が少ない状態から順番に探索していく

### 状態の表現
各状態を `(マス番号, フェーズ)` で表現します：

- **フェーズ0**：次にサイコロを振る状態
- **フェーズ1**：マスの数を使うかどうか選択できる状態

### 移動のパターン

#### コスト1の移動（サイコロを振る）
```
(マス, フェーズ0) → (マス+1〜6, フェーズ1)
```

#### コスト0の移動（選択による移動）
```
(マス, フェーズ1) → (マス, フェーズ0)     # 進まない選択
(マス, フェーズ1) → (マス+値, フェーズ1)   # 進む選択
```

## アルゴリズムの流れ

### 1. 初期化
```python
# 距離配列：dist[マス][フェーズ] = そこに到達する最小サイコロ回数
dist = [[無限大] * 2 for _ in range(N+1)]
dist[0][0] = 0  # スタート地点
```

### 2. BFSの実行
各サイコロ回数について、その回数で到達できる全ての状態を調べます。

```python
rolls = 0  # 現在のサイコロ回数
while まだ探索する状態がある:
    # このターン(rolls回)で到達可能な状態を全て洗い出す
    # ↓
    # 次のターン(rolls+1回)で到達可能な状態を計算
    rolls += 1
```

### 3. 状態の更新

#### 同一ターン内での移動（コスト0）
フェーズ1の状態から：
- **進まない** → 同じマスのフェーズ0へ
- **進む** → 値の分だけ進んだマスのフェーズ1へ

#### 次ターンへの移動（コスト1）
フェーズ0の状態から：
- **サイコロを振る** → 1〜6進んだマスのフェーズ1へ

## 実装のポイント

### dequeの使用
```python
from collections import deque

q_curr = deque()  # 現在のターンで処理する状態
q_next = deque()  # 次のターンで処理する状態
```

BFSでは先頭から要素を取り出すことが多いので、`deque`を使うと効率的です。

### 同一ターン内の処理
```python
q_zero_cost = deque(q_curr)
visited_in_level = set(q_curr)

while q_zero_cost:
    pos, phase = q_zero_cost.popleft()
    
    if phase == 1:  # 選択できる状態
        # 進まない選択
        if cost < dist[pos][0]:
            dist[pos][0] = cost
            q_zero_cost.append((pos, 0))
        
        # 進む選択
        next_pos = pos + A[pos]
        if cost < dist[next_pos][1]:
            dist[next_pos][1] = cost
            q_zero_cost.append((next_pos, 1))
```

### 次ターンへの遷移
```python
for pos, phase in visited_in_level:
    if dist[pos][0] == rolls:  # このターンでフェーズ0に到達した状態
        for roll in range(1, 7):  # サイコロで1〜6
            next_pos = pos + roll
            if rolls + 1 < dist[next_pos][1]:
                dist[next_pos][1] = rolls + 1
                q_next.append((next_pos, 1))
```

## 例題での動作確認

```
10
0 0 0 0 0 1 1 1 1
```

### rolls = 0
- 初期状態：`(0, フェーズ0)` コスト0

### rolls = 1
- サイコロで6を振る：`(6, フェーズ1)` コスト1
- マス6の値1で進む：`(7, フェーズ1)` コスト1
- マス7の値1で進む：`(8, フェーズ1)` コスト1
- ...
- マス9の値1で進む：`(10, フェーズ1)` コスト1 → **ゴール！**

答え：1回

## 計算量について

- **時間計算量**：O(N)
  - 各マスは最大で定数回しか訪問されない
  - N=100,000でも高速に動作

- **空間計算量**：O(N)
  - 距離配列とキューのサイズ

## まとめ

この問題のポイントは：

1. **2つのフェーズ**を区別して状態管理
2. **BFS**で最小サイコロ回数を保証
3. **コスト0移動**と**コスト1移動**を分けて処理
4. **deque**を使った効率的な実装

最初は複雑に見えますが、状態を整理してBFSの枠組みで考えると理解しやすくなります。類似問題でも同じパターンが使えるので、ぜひマスターしてください！